using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp;
using TestGeneratorLib.Model;

namespace TestGeneratorLib.Block
{
    public static class CodeCreator
    {
        private static readonly SyntaxToken PublicModifier;

        //Test class attribute ("TestFixture") 
        private static readonly AttributeSyntax ClassAttribute;
        
        //Setup method attribute ("SetUp") 
        private static readonly AttributeSyntax SetupAttribute;

        //Test method attribute ("Test") 
        private static readonly AttributeSyntax MethodAttribute;

        //Assert.Fail("autogenerated") expression 
        private static readonly ExpressionStatementSyntax FailExpression;

        //Test method return type (void)
        private static readonly TypeSyntax ReturnType;

        static CodeCreator()
        {
            //Modifiers
            PublicModifier = Token(SyntaxKind.PublicKeyword);

            //Attributes
            ClassAttribute = Attribute(ParseName("TestFicture"));
            SetupAttribute = Attribute(ParseName("SetUp"));
            MethodAttribute = Attribute(ParseName("Test"));

            //Assert.Fail()
            FailExpression = CreateFailExpression();

            //Return type
            ReturnType = ParseTypeName("void");
        }

        public static Dictionary<string, string> GenerateTests(FileData fileData)
        {
            //Get all classes and generate test for them
            var testFiles = new Dictionary<string, string>();
            foreach(var classData in fileData.ClassesData)
            {
                var classNode = GenerateClass(classData);

                var testUnit = CompilationUnit()
                    .AddUsings(UsingDirective(ParseName("System")))
                    .AddUsings(UsingDirective(ParseName("System.Collections.Generic")))
                    .AddUsings(UsingDirective(ParseName("NUnit.Framework")))
                    .AddUsings(UsingDirective(ParseName("Moq")))
                    .AddMembers(classNode);

                testFiles.Add(classData.Name + "Test", testUnit.NormalizeWhitespace().ToFullString());
            }

            return testFiles;
        }

        private static ClassDeclarationSyntax GenerateClass(ClassData classData)
        {
            VariableDeclarationSyntax variable;
            var fields = new List<FieldDeclarationSyntax>();

            //Generate interfases
            ConstructorData constructor = null;
            if(classData.ConstructorData.Count > 0)
            {
                constructor = FindLargestConstructor(classData.ConstructorData);

                var interfaces = ProcessCustomType(constructor.Parameters);
                foreach(var custom in interfaces)
                {
                    variable = GenerateVariable($"Mock<{custom.Value}>", custom.Key);
                    fields.Add(GenerateField(variable));
                }
            }

            //Generate class properties
            variable = GenerateVariable(classData.Name, ProcessVariable(classData.Name));
            fields.Add(GenerateField(variable));

            //Generate methods
            var methods = new List<MethodDeclarationSyntax>();
            methods.Add(GenerateSetUpMethod(constructor, classData.Name));
            foreach(var methodInfo in classData.MethodsData) { methods.Add(GenerateMethod(methodInfo, classData.Name)); }

            //Format class
            return ClassDeclaration(classData.Name + "Test")
                .AddMembers(fields.ToArray())
                .AddMembers(methods.ToArray())
                .AddAttributeLists(AttributeList(AttributeList().Attributes.Add(ClassAttribute)));
        }


        //Generate method node
        private static MethodDeclarationSyntax GenerateMethod(MethodData methodData, string classVariable)
        {
            //Generate method body
            var body = new List<StatementSyntax>();

            GenerateArrangePart(body, methodData.Parameters);
            GenerateActPart(body, methodData, classVariable);

            if (methodData.ReturnType != "void")
            {
                GenerateAssertPart(body, methodData.ReturnType);
            }

            body.Add(FailExpression);

            // Format method information
            return MethodDeclaration(ReturnType, methodData.Name)
                .AddModifiers(PublicModifier)
                .AddAttributeLists(AttributeList(AttributeList().Attributes.Add(MethodAttribute)))
                .WithBody(SyntaxFactory.Block(body));
        }

        //Assert section
        private static void GenerateAssertPart(List<StatementSyntax> body, string returnType)
        {
            // Get expected value
            body.Add(GenerateBaseTypesAssignStatement("expected", returnType));

            // Get check Assert.That(actual, Is.EqualTo(expected))
            var invocationExpression = GenerateExpression("Assert", "That");
            var secondPart = GenerateExpression("Is", "EqualTo")
                .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(
                    new SyntaxNodeOrToken[] {
                        Argument(IdentifierName("expected"))
                    }
                )));
            var argList = ArgumentList(SeparatedList<ArgumentSyntax>(
                    new SyntaxNodeOrToken[] {
                        Argument(IdentifierName("actual")),
                        Token(SyntaxKind.CommaToken),
                        Argument(IdentifierName(secondPart.ToString()))
                    }
                ));

            // Add to body
            var s = ExpressionStatement(invocationExpression.WithArgumentList(argList));
            body.Add(s);
        }

        //Get expression
        private static InvocationExpressionSyntax GenerateExpression(string firstCall, string secondCall)
        {
            return InvocationExpression(MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression, IdentifierName(firstCall), IdentifierName(secondCall)
            ));
        }

        //Get act section
        private static void GenerateActPart(List<StatementSyntax> body, MethodData methodData, string classVariable)
        {
            if (methodData.ReturnType != "void")
            {
                body.Add(GenerateFunctionCall("actual", ProcessVariable(classVariable) + "." + methodData.Name,
                    ConvertParametersToStringRepresentation(methodData.Parameters)));
            }
            else
            {
                body.Add(GenerateVoidFunctionCall(ProcessVariable(classVariable) + "." + methodData.Name,
                    ConvertParametersToStringRepresentation(methodData.Parameters)));
            }
        }

        private static StatementSyntax GenerateFunctionCall(string varName, string funcName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("var {0} = {1}{2};", varName, funcName, $"({invokeArgs})"));
        }

        private static StatementSyntax GenerateVoidFunctionCall(string funcName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("{0}{1};", funcName, $"({invokeArgs})"));
        }

        //Arrange section
        private static void GenerateArrangePart(List<StatementSyntax> body, Dictionary<string, string> parameters)
        {
            var baseTypeVars = ProcessBaseType(parameters);
            foreach (var var in baseTypeVars)
            {
                body.Add(GenerateBaseTypesAssignStatement(var.Key, var.Value));
            }
        }

        //Genetare setup method
        private static MethodDeclarationSyntax GenerateSetUpMethod(ConstructorData constructorData, string className)
        {
            //Get Setup method body
            var body = new List<StatementSyntax>();
            if(constructorData != null)
            {
                var baseTypeVars = ProcessBaseType(constructorData.Parameters);
                foreach(var var in baseTypeVars) { body.Add(GenerateBaseTypesAssignStatement(var.Key, var.Value)); }

                var customVars = ProcessCustomType(constructorData.Parameters);
                foreach(var var in customVars) { body.Add(GenerateCustomsTypesAssignStatement(var.Key, $"Mock<{var.Value}>")); }
            }

            //Add body
            body.Add(GenerateCustomsTypesAssignStatement(ProcessVariable(className),
                                                         className,
                                                         constructorData != null ? ConvertParametersToStringRepresentation(constructorData.Parameters) : ""
                                                         )
                     );

            //Format setup method
            return MethodDeclaration(ReturnType, "SetUp")
                   .AddModifiers(PublicModifier)
                   .AddAttributeLists(AttributeList(AttributeList()
                                                    .Attributes.Add(SetupAttribute)))
                   .WithBody(SyntaxFactory.Block(body)
                   );
        }

        //Get string representation
        private static string ConvertParametersToStringRepresentation(Dictionary<string, string> parameters)
        {
            var s = "";
            foreach (var pair in parameters)
            {
                s += pair.Value[0] == 'I' ? $"{pair.Key}.Object" : $"{pair.Key}";
                s += ", ";
            }

            return s.Length > 0 ? s.Remove(s.Length - 2, 2) : "";
        }

        //Get base type node
        private static StatementSyntax GenerateBaseTypesAssignStatement(string name, string type)
        {
            return ParseStatement(string.Format("var {0} = default({1});", name, type));
        }

        //Get custop type node
        private static StatementSyntax GenerateCustomsTypesAssignStatement(string name, string constructorName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("{0} = new {1}{2};", name, constructorName, $"({invokeArgs})"));
        }

        //Format base type
        private static Dictionary<string, string> ProcessBaseType(Dictionary<string, string> parameters)
        {
            var types = new Dictionary<string, string>();
            foreach(var parameter in parameters)
            {
                //If not an interfase
                if(parameter.Value[0] != 'I') { types.Add(parameter.Key, parameter.Value); }
            }

            return types;
        }

        //Create variable name from type
        private static string ProcessVariable(string type)
        {
            return type[0].ToString().ToLower() + type.Remove(0, 1);
        }

        //Generate field node
        private static FieldDeclarationSyntax GenerateField(VariableDeclarationSyntax variable)
        {
            return FieldDeclaration(variable).AddModifiers(Token(SyntaxKind.PrivateKeyword));
        }

        //Generate variable with type
        private static VariableDeclarationSyntax GenerateVariable(string type, string name)
        {
            return VariableDeclaration(ParseTypeName(type)).AddVariables(VariableDeclarator(name));
        }

        //Format custom type
        private static Dictionary<string, string> ProcessCustomType(Dictionary<string, string> parameters)
        {
            var types = new Dictionary<string, string>();
            foreach (var parameter in parameters)
            {
                //if in interfase
                if (parameter.Value[0] == 'I') { types.Add(parameter.Key, parameter.Value); }
            }

            return types;
        }

        //Find constructor with largest parameters count
        private static ConstructorData FindLargestConstructor(List<ConstructorData> constructorsData)
        {
            var constructor = constructorsData[0];
            foreach(var temp in constructorsData)
            {
                if (constructor.Parameters.Count < temp.Parameters.Count) { constructor = temp; }

            }

            return constructor;
        }

        

        private static ExpressionStatementSyntax CreateFailExpression()
        {
            return ExpressionStatement(InvocationExpression(
                                       MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("Assert"), IdentifierName("Fail")))
                                       .WithArgumentList(ArgumentList(SingletonSeparatedList<ArgumentSyntax>(
                                                                      Argument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("aotugenerated")))
                                                                      ))
                                                        )
                                       );
        }
    }
}
